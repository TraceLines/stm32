## 当在 bsp 文件夹中添加了项目中，如何集成进 cmake 之中？并被主程序所使用？

- 一个基本原则是保持 stm32CubeMx 所生成的基本结构，因为在后面的开发过程中，可能会涉及到项目的修改，虽然达里，这个项目因为历史的原因，不会再进入 cubemx 之中修改，但是应该保持一个好的习惯。
- 另外一点是，使用 bps 板级支持，也就是整个项目工程化。
  deepseek 的的建议是在 bsp 那里添加一个 bps.c，用于总入口，原计算是不想添加的，想像 driver 那样，直接引入，可是看到它是初始化入口，我想这个入口还是必要的。
- 还有一个问题是，应该如何设计程序与数据结构的问题，这是之前在嵌入式之中从来没有考虑过的问题。

## 一个疑惑是，在 led1.c 文件中，需要使用到 GPIO 这样的端口时时，要不要在这个文件中重新引入这个头文件。

- 考虑的是什么？比如说在 main 中已经引入这个文件的情况下，在这里是否有必要重复引入？
  头文件的作用是什么？是一种预处理，一种声明上的，被预处理器处理时，是地种展开，所以我觉得应该引用。
  如果引用，那引用谁呢？

#### 先来思考在 main.c 中的引用逻辑是什么？

main.c --> main.h --> #include "stm32f1xx_hal.h" --> #include "stm32f1xx_hal_conf.h"

stm32f1xx_hal 这个文件的说明第一个就是：This file contains all the functions prototypes for the HAL module driver，在这个文件中，它并没有多少内容，而是引用了后面的 conf.h 文件。这个文件根据在 cubemx 中的定义，引入了相关的头文件。所以它确实做到了包含所有头文件，也就是实现了所有 HAL 的函数原型。

那么在 main.c 中引入了这些头文件，在 led1.h 之中还要引用吗？

- 一个答案是看 Driver 之中的源文件的引用方式，在 gpio 中，使用的是引入 HAL 一个库，即 stm32f1xx_hal.h 这个头文件

#### 另一个问题是，应该如何避免重复引入的问题！这是一个什么问题？它是 c 语言之中的问题，还是编译器问题？

我想，它应该是一种编译器的问题，为什么会有这个重复加载的问题存在？

还要考虑用户可能的后续问题，比如如何添加新的外设驱动，如何修改 CMake 配置，或者调试时需要注意的事项。可能需要准备一些例子，比如 GPIO 的使用或中断处理，但当前问题主要是结构介绍。

### main.c 之中的 MX_GPIO_Init 函数，它是由 mx 生成的一些初始化方法

这里的一些引脚的声明与定义，可以挪走，而时钟方面的，则留下来。
